var y=Object.defineProperty;var p=e=>{throw TypeError(e)};var B=(e,t,r)=>t in e?y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var i=(e,t,r)=>B(e,typeof t!="symbol"?t+"":t,r),U=(e,t,r)=>t.has(e)||p("Cannot "+r);var s=(e,t,r)=>(U(e,t,"read from private field"),r?r.call(e):t.get(e)),h=(e,t,r)=>t.has(e)?p("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),I=(e,t,r,a)=>(U(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r);var n;(function(e){e.LOAD="LOAD",e.EXEC="EXEC",e.FFPROBE="FFPROBE",e.WRITE_FILE="WRITE_FILE",e.READ_FILE="READ_FILE",e.DELETE_FILE="DELETE_FILE",e.RENAME="RENAME",e.CREATE_DIR="CREATE_DIR",e.LIST_DIR="LIST_DIR",e.DELETE_DIR="DELETE_DIR",e.ERROR="ERROR",e.DOWNLOAD="DOWNLOAD",e.PROGRESS="PROGRESS",e.LOG="LOG",e.MOUNT="MOUNT",e.UNMOUNT="UNMOUNT"})(n||(n={}));const C=(()=>{let e=0;return()=>e++})(),P=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),T=new Error("called FFmpeg.terminate()");var R,l,c,D,u,A,E;class X{constructor(){h(this,R,null);h(this,l,{});h(this,c,{});h(this,D,[]);h(this,u,[]);i(this,"loaded",!1);h(this,A,()=>{s(this,R)&&(s(this,R).onmessage=({data:{id:t,type:r,data:a}})=>{switch(r){case n.LOAD:this.loaded=!0,s(this,l)[t](a);break;case n.MOUNT:case n.UNMOUNT:case n.EXEC:case n.FFPROBE:case n.WRITE_FILE:case n.READ_FILE:case n.DELETE_FILE:case n.RENAME:case n.CREATE_DIR:case n.LIST_DIR:case n.DELETE_DIR:s(this,l)[t](a);break;case n.LOG:s(this,D).forEach(o=>o(a));break;case n.PROGRESS:s(this,u).forEach(o=>o(a));break;case n.ERROR:s(this,c)[t](a);break}delete s(this,l)[t],delete s(this,c)[t]})});h(this,E,({type:t,data:r},a=[],o)=>s(this,R)?new Promise((d,f)=>{const O=C();s(this,R)&&s(this,R).postMessage({id:O,type:t,data:r},a),s(this,l)[O]=d,s(this,c)[O]=f,o==null||o.addEventListener("abort",()=>{f(new DOMException(`Message # ${O} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(P));i(this,"load",({classWorkerURL:t,...r}={},{signal:a}={})=>(s(this,R)||(I(this,R,t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL(""+new URL("../../assets/worker-BAOIWoxA.js",import.meta.url).href,import.meta.url),{type:"module"})),s(this,A).call(this)),s(this,E).call(this,{type:n.LOAD,data:r},void 0,a)));i(this,"exec",(t,r=-1,{signal:a}={})=>s(this,E).call(this,{type:n.EXEC,data:{args:t,timeout:r}},void 0,a));i(this,"ffprobe",(t,r=-1,{signal:a}={})=>s(this,E).call(this,{type:n.FFPROBE,data:{args:t,timeout:r}},void 0,a));i(this,"terminate",()=>{const t=Object.keys(s(this,c));for(const r of t)s(this,c)[r](T),delete s(this,c)[r],delete s(this,l)[r];s(this,R)&&(s(this,R).terminate(),I(this,R,null),this.loaded=!1)});i(this,"writeFile",(t,r,{signal:a}={})=>{const o=[];return r instanceof Uint8Array&&o.push(r.buffer),s(this,E).call(this,{type:n.WRITE_FILE,data:{path:t,data:r}},o,a)});i(this,"mount",(t,r,a)=>{const o=[];return s(this,E).call(this,{type:n.MOUNT,data:{fsType:t,options:r,mountPoint:a}},o)});i(this,"unmount",t=>{const r=[];return s(this,E).call(this,{type:n.UNMOUNT,data:{mountPoint:t}},r)});i(this,"readFile",(t,r="binary",{signal:a}={})=>s(this,E).call(this,{type:n.READ_FILE,data:{path:t,encoding:r}},void 0,a));i(this,"deleteFile",(t,{signal:r}={})=>s(this,E).call(this,{type:n.DELETE_FILE,data:{path:t}},void 0,r));i(this,"rename",(t,r,{signal:a}={})=>s(this,E).call(this,{type:n.RENAME,data:{oldPath:t,newPath:r}},void 0,a));i(this,"createDir",(t,{signal:r}={})=>s(this,E).call(this,{type:n.CREATE_DIR,data:{path:t}},void 0,r));i(this,"listDir",(t,{signal:r}={})=>s(this,E).call(this,{type:n.LIST_DIR,data:{path:t}},void 0,r));i(this,"deleteDir",(t,{signal:r}={})=>s(this,E).call(this,{type:n.DELETE_DIR,data:{path:t}},void 0,r))}on(t,r){t==="log"?s(this,D).push(r):t==="progress"&&s(this,u).push(r)}off(t,r){t==="log"?I(this,D,s(this,D).filter(a=>a!==r)):t==="progress"&&I(this,u,s(this,u).filter(a=>a!==r))}}R=new WeakMap,l=new WeakMap,c=new WeakMap,D=new WeakMap,u=new WeakMap,A=new WeakMap,E=new WeakMap;var S;(function(e){e.MEMFS="MEMFS",e.NODEFS="NODEFS",e.NODERAWFS="NODERAWFS",e.IDBFS="IDBFS",e.WORKERFS="WORKERFS",e.PROXYFS="PROXYFS"})(S||(S={}));const W=new Error("failed to get response body reader"),k=new Error("failed to complete download"),g="Content-Length",M=e=>new Promise((t,r)=>{const a=new FileReader;a.onload=()=>{const{result:o}=a;o instanceof ArrayBuffer?t(new Uint8Array(o)):t(new Uint8Array)},a.onerror=o=>{var d,f;r(Error(`File could not be read! Code=${((f=(d=o==null?void 0:o.target)==null?void 0:d.error)==null?void 0:f.code)||-1}`))},a.readAsArrayBuffer(e)}),j=async e=>{let t;if(typeof e=="string")/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(e)?t=atob(e.split(",")[1]).split("").map(r=>r.charCodeAt(0)):t=await(await fetch(e)).arrayBuffer();else if(e instanceof URL)t=await(await fetch(e)).arrayBuffer();else if(e instanceof File||e instanceof Blob)t=await M(e);else return new Uint8Array;return new Uint8Array(t)},F=async(e,t)=>{var o;const r=await fetch(e);let a;try{const d=parseInt(r.headers.get(g)||"-1"),f=(o=r.body)==null?void 0:o.getReader();if(!f)throw W;const O=[];let w=0;for(;;){const{done:L,value:_}=await f.read(),N=_?_.length:0;if(L){if(d!=-1&&d!==w)throw k;t&&t({url:e,total:d,received:w,delta:N,done:L});break}O.push(_),w+=N,t&&t({url:e,total:d,received:w,delta:N,done:L})}const m=new Uint8Array(w);let b=0;for(const L of O)m.set(L,b),b+=L.length;a=m.buffer}catch(d){console.log("failed to send download progress event: ",d),a=await r.arrayBuffer()}return a},x=async(e,t,r=!1,a)=>{const o=r?await F(e,a):await(await fetch(e)).arrayBuffer(),d=new Blob([o],{type:t});return URL.createObjectURL(d)};export{X as F,j as f,x as t};
